diff --git a/src/gst-plugins/rtpendpoint/kmssiprtpendpoint.c b/src/gst-plugins/rtpendpoint/kmssiprtpendpoint.c
index 56732f9..d7d873e 100644
--- a/src/gst-plugins/rtpendpoint/kmssiprtpendpoint.c
+++ b/src/gst-plugins/rtpendpoint/kmssiprtpendpoint.c
@@ -34,14 +34,12 @@
 #define DEFAULT_AUDIO_SSRC 0
 #define DEFAULT_VIDEO_SSRC 0
 
-
 GST_DEBUG_CATEGORY_STATIC (kms_sip_rtp_endpoint_debug);
 #define GST_CAT_DEFAULT kms_sip_rtp_endpoint_debug
 
 #define kms_sip_rtp_endpoint_parent_class parent_class
 G_DEFINE_TYPE (KmsSipRtpEndpoint, kms_sip_rtp_endpoint, KMS_TYPE_RTP_ENDPOINT);
 
-
 #define KMS_SIP_RTP_ENDPOINT_GET_PRIVATE(obj) (  \
   G_TYPE_INSTANCE_GET_PRIVATE (              \
     (obj),                                   \
@@ -50,19 +48,17 @@ G_DEFINE_TYPE (KmsSipRtpEndpoint, kms_sip_rtp_endpoint, KMS_TYPE_RTP_ENDPOINT);
   )                                          \
 )
 
-
 typedef struct _KmsSipRtpEndpointCloneData KmsSipRtpEndpointCloneData;
 
-
 struct _KmsSipRtpEndpointCloneData
 {
-	guint32 local_audio_ssrc;
-	guint32 local_video_ssrc;
+  guint32 local_audio_ssrc;
+  guint32 local_video_ssrc;
 
-	SipFilterSsrcInfo* audio_filter_info;
-	SipFilterSsrcInfo* video_filter_info;
+  SipFilterSsrcInfo *audio_filter_info;
+  SipFilterSsrcInfo *video_filter_info;
 
-	GHashTable *conns;
+  GHashTable *conns;
 };
 
 struct _KmsSipRtpEndpointPrivate
@@ -80,7 +76,6 @@ enum
   PROP_VIDEO_SSRC
 };
 
-
 /* Signals and args */
 enum
 {
@@ -94,135 +89,159 @@ static guint obj_signals[LAST_SIGNAL] = { 0 };
 
 static KmsBaseSdpEndpointClass *base_sdp_endpoint_type;
 
-
 /*----------- Session cloning ---------------*/
 
 static void
-kms_sip_rtp_endpoint_clone_rtp_session (GstElement * rtpbin, guint sessionId, guint32 ssrc, gchar *rtpbin_pad_name)
+kms_sip_rtp_endpoint_clone_rtp_session (GstElement * rtpbin, guint sessionId,
+    guint32 ssrc, gchar * rtpbin_pad_name)
 {
-	GObject *rtpSession;
-    GstPad *pad;
+  GObject *rtpSession;
+  GstPad *pad;
 
-	/* Create RtpSession requesting the pad */
-	pad = gst_element_get_request_pad (rtpbin, rtpbin_pad_name);
-	g_object_unref (pad);
+  /* Create RtpSession requesting the pad */
+  pad = gst_element_get_request_pad (rtpbin, rtpbin_pad_name);
+  g_object_unref (pad);
 
-	g_signal_emit_by_name (rtpbin, "get-internal-session", sessionId, &rtpSession);
-	if (rtpSession != NULL) {
-		g_object_set (rtpSession, "internal-ssrc", ssrc, NULL);
-	}
+  g_signal_emit_by_name (rtpbin, "get-internal-session", sessionId,
+      &rtpSession);
+  if (rtpSession != NULL) {
+    g_object_set (rtpSession, "internal-ssrc", ssrc, NULL);
+  }
 
-	g_object_unref(rtpSession);
+  g_object_unref (rtpSession);
 }
-static GstElement*
+
+static GstElement *
 kms_sip_rtp_endpoint_get_rtpbin (KmsSipRtpEndpoint * self)
 {
-	GstElement *result = NULL;
-	GList* rtpEndpointChildren = GST_BIN_CHILDREN(GST_BIN(self));
-
-	while (rtpEndpointChildren != NULL) {
-		gchar* objectName = gst_element_get_name  (GST_ELEMENT(rtpEndpointChildren->data));
-
-		if (g_str_has_prefix (objectName, "rtpbin")) {
-			result = GST_ELEMENT(rtpEndpointChildren->data);
-			g_free (objectName);
-			break;
-		}
-		g_free (objectName);
-		rtpEndpointChildren = rtpEndpointChildren->next;
-	}
-	return result;
+  GstElement *result = NULL;
+  GList *rtpEndpointChildren = GST_BIN_CHILDREN (GST_BIN (self));
+
+  while (rtpEndpointChildren != NULL) {
+    gchar *objectName =
+        gst_element_get_name (GST_ELEMENT (rtpEndpointChildren->data));
+
+    if (g_str_has_prefix (objectName, "rtpbin")) {
+      result = GST_ELEMENT (rtpEndpointChildren->data);
+      g_free (objectName);
+      break;
+    }
+    g_free (objectName);
+    rtpEndpointChildren = rtpEndpointChildren->next;
+  }
+  return result;
 }
 
-static KmsSipRtpEndpointCloneData*
-kms_sip_rtp_endpoint_get_clone_data (GList *sessionData)
+static KmsSipRtpEndpointCloneData *
+kms_sip_rtp_endpoint_get_clone_data (GList * sessionData)
 {
-	if (sessionData == NULL)
-		return NULL;
-	return ((KmsSipRtpEndpointCloneData*)sessionData->data);
+  if (sessionData == NULL)
+    return NULL;
+  return ((KmsSipRtpEndpointCloneData *) sessionData->data);
 }
 
 static void
-kms_sip_rtp_endpoint_preserve_rtp_session_data (KmsSipRtpSession *ses,
-		GHashTable *conns)
+kms_sip_rtp_endpoint_preserve_rtp_session_data (KmsSipRtpSession * ses,
+    GHashTable * conns)
 {
-	KMS_SIP_RTP_SESSION_CLASS(G_OBJECT_GET_CLASS(ses))->clone_connections (ses,conns);
+  KMS_SIP_RTP_SESSION_CLASS (G_OBJECT_GET_CLASS (ses))->clone_connections (ses,
+      conns);
 }
 
 static void
-kms_sip_rtp_endpoint_preserve_srtp_session_data (KmsSipSrtpSession *ses,
-		GHashTable *conns)
+kms_sip_rtp_endpoint_preserve_srtp_session_data (KmsSipSrtpSession * ses,
+    GHashTable * conns)
 {
-	KMS_SIP_SRTP_SESSION_CLASS(G_OBJECT_GET_CLASS(ses))->clone_connections (ses,conns);
+  KMS_SIP_SRTP_SESSION_CLASS (G_OBJECT_GET_CLASS (ses))->clone_connections (ses,
+      conns);
 }
 
 static void
-kms_sip_rtp_endpoint_clone_session (KmsSipRtpEndpoint * self, KmsSdpSession ** sess)
+kms_sip_rtp_endpoint_clone_session (KmsSipRtpEndpoint * self,
+    KmsSdpSession ** sess)
 {
-	GstElement *rtpbin = kms_sip_rtp_endpoint_get_rtpbin (self);
-	GList *sessionToClone = self->priv->sessionData;
-
-	if (rtpbin != NULL) {
-		gboolean is_srtp = FALSE;
-
-		is_srtp = KMS_IS_SIP_SRTP_SESSION (*sess);
-		// TODO: Multisession seems not used on RTPEndpoint, anyway we are doing something probably incorrect
-		// once multisession is used, that is to assume that creation order of sessions are maintained among all
-		// endpoints, and so order can be used to correlate internal rtp sessions.
-		KmsBaseRtpSession *clonedSes = KMS_BASE_RTP_SESSION (*sess);
-		guint32 ssrc;
-		GHashTable *conns;
-
-		conns = kms_sip_rtp_endpoint_get_clone_data(sessionToClone)->conns;
-
-		/* TODO: think about this when multiple audio/video medias */
-		// Audio
-		//      Clone SSRC
-		ssrc = kms_sip_rtp_endpoint_get_clone_data(sessionToClone)->local_audio_ssrc;
-		clonedSes->local_audio_ssrc = ssrc;
-		kms_sip_rtp_endpoint_clone_rtp_session (rtpbin, AUDIO_RTP_SESSION, ssrc, AUDIO_RTPBIN_SEND_RTP_SINK);
-
-		// Video
-		//        Clone SSRC
-		ssrc = kms_sip_rtp_endpoint_get_clone_data(sessionToClone)->local_video_ssrc;
-		clonedSes->local_video_ssrc = ssrc;
-		kms_sip_rtp_endpoint_clone_rtp_session (rtpbin, VIDEO_RTP_SESSION, ssrc, VIDEO_RTPBIN_SEND_RTP_SINK);
-
-		if (is_srtp) {
-			kms_sip_rtp_endpoint_preserve_srtp_session_data (KMS_SIP_SRTP_SESSION(*sess), conns);
-		} else {
-			kms_sip_rtp_endpoint_preserve_rtp_session_data (KMS_SIP_RTP_SESSION(*sess), conns);
-		}
-	}
+  GstElement *rtpbin = kms_sip_rtp_endpoint_get_rtpbin (self);
+  GList *sessionToClone = self->priv->sessionData;
+
+  if (rtpbin != NULL) {
+    gboolean is_srtp = FALSE;
+
+    is_srtp = KMS_IS_SIP_SRTP_SESSION (*sess);
+    // TODO: Multisession seems not used on RTPEndpoint, anyway we are doing something probably incorrect
+    // once multisession is used, that is to assume that creation order of sessions are maintained among all
+    // endpoints, and so order can be used to correlate internal rtp sessions.
+    KmsBaseRtpSession *clonedSes = KMS_BASE_RTP_SESSION (*sess);
+    guint32 ssrc;
+    GHashTable *conns;
+
+    conns = kms_sip_rtp_endpoint_get_clone_data (sessionToClone)->conns;
+
+    /* TODO: think about this when multiple audio/video medias */
+    // Audio
+    //      Clone SSRC
+    ssrc =
+        kms_sip_rtp_endpoint_get_clone_data (sessionToClone)->local_audio_ssrc;
+    clonedSes->local_audio_ssrc = ssrc;
+    kms_sip_rtp_endpoint_clone_rtp_session (rtpbin, AUDIO_RTP_SESSION, ssrc,
+        AUDIO_RTPBIN_SEND_RTP_SINK);
+
+    // Video
+    //        Clone SSRC
+    ssrc =
+        kms_sip_rtp_endpoint_get_clone_data (sessionToClone)->local_video_ssrc;
+    clonedSes->local_video_ssrc = ssrc;
+    kms_sip_rtp_endpoint_clone_rtp_session (rtpbin, VIDEO_RTP_SESSION, ssrc,
+        VIDEO_RTPBIN_SEND_RTP_SINK);
+
+    if (is_srtp) {
+      kms_sip_rtp_endpoint_preserve_srtp_session_data (KMS_SIP_SRTP_SESSION
+          (*sess), conns);
+    } else {
+      kms_sip_rtp_endpoint_preserve_rtp_session_data (KMS_SIP_RTP_SESSION
+          (*sess), conns);
+    }
+  }
 }
 
-
-
-static gboolean isUseSdes (KmsSipRtpEndpoint * self)
+static gboolean
+isUseSdes (KmsSipRtpEndpoint * self)
 {
-	if (self->priv->use_sdes_cache == NULL) {
-		gboolean useSdes;
-
-		g_object_get (G_OBJECT(self), "use-sdes", &useSdes, NULL);
-		self->priv->use_sdes_cache = g_malloc(sizeof(gboolean));
-		*self->priv->use_sdes_cache = useSdes;
-	}
-	return *self->priv->use_sdes_cache;
-}
+  if (self->priv->use_sdes_cache == NULL) {
+    gboolean useSdes;
 
+    g_object_get (G_OBJECT (self), "use-sdes", &useSdes, NULL);
+    self->priv->use_sdes_cache = g_malloc (sizeof (gboolean));
+    *self->priv->use_sdes_cache = useSdes;
+  }
+  return *self->priv->use_sdes_cache;
+}
 
 static void
 kms_sip_rtp_endpoint_set_addr (KmsSipRtpEndpoint * self)
 {
   GList *ips, *l;
   gboolean done = FALSE;
+  gboolean use_ipv6;
+  gchar *external_ip;
+
+  g_object_get (self, "use-ipv6", &use_ipv6, NULL);
+
+  g_object_get (self, use_ipv6 ? "external-ipv6" : "external-ipv4",
+      &external_ip, NULL);
+
+  if (external_ip != NULL) {
+    g_object_set (self, "addr", external_ip, NULL);
+    g_free (external_ip);
+    done = TRUE;
+    return;
+  }
 
   ips = nice_interfaces_get_local_ips (FALSE);
   for (l = ips; l != NULL && !done; l = l->next) {
     GInetAddress *addr;
     gboolean is_ipv6 = FALSE;
 
-    GST_DEBUG_OBJECT (self, "Check local address: %s", (const gchar*)l->data);
+    GST_DEBUG_OBJECT (self, "Check local address: %s", (const gchar *) l->data);
     addr = g_inet_address_new_from_string (l->data);
 
     if (G_IS_INET_ADDRESS (addr)) {
@@ -236,9 +255,7 @@ kms_sip_rtp_endpoint_set_addr (KmsSipRtpEndpoint * self)
         case G_SOCKET_FAMILY_IPV4:
         {
           gchar *addr_str;
-          gboolean use_ipv6;
 
-          g_object_get (self, "use-ipv6", &use_ipv6, NULL);
           if (is_ipv6 != use_ipv6) {
             GST_DEBUG_OBJECT (self, "Skip address (wanted IPv6: %d)", use_ipv6);
             break;
@@ -280,22 +297,24 @@ kms_sip_rtp_endpoint_create_session_internal (KmsBaseSdpEndpoint * base_sdp,
   kms_sip_rtp_endpoint_set_addr (self);
 
   g_object_get (self, "use-ipv6", &use_ipv6, NULL);
-  if (isUseSdes(self)) {
-	KmsSipSrtpSession *sip_srtp_ses = kms_sip_srtp_session_new (base_sdp, id, manager, use_ipv6);
+  if (isUseSdes (self)) {
+    KmsSipSrtpSession *sip_srtp_ses =
+        kms_sip_srtp_session_new (base_sdp, id, manager, use_ipv6);
     *sess = KMS_SDP_SESSION (sip_srtp_ses);
-	if (self->priv->sessionData != NULL) {
-		data = (KmsSipRtpEndpointCloneData*) self->priv->sessionData->data;
-		sip_srtp_ses->audio_filter_info = data->audio_filter_info;
-		sip_srtp_ses->video_filter_info = data->video_filter_info;
-	}
+    if (self->priv->sessionData != NULL) {
+      data = (KmsSipRtpEndpointCloneData *) self->priv->sessionData->data;
+      sip_srtp_ses->audio_filter_info = data->audio_filter_info;
+      sip_srtp_ses->video_filter_info = data->video_filter_info;
+    }
   } else {
-	KmsSipRtpSession *sip_rtp_ses = kms_sip_rtp_session_new (base_sdp, id, manager, use_ipv6);
+    KmsSipRtpSession *sip_rtp_ses =
+        kms_sip_rtp_session_new (base_sdp, id, manager, use_ipv6);
     *sess = KMS_SDP_SESSION (sip_rtp_ses);
-	if (self->priv->sessionData != NULL) {
-		data = (KmsSipRtpEndpointCloneData*) self->priv->sessionData->data;
-		sip_rtp_ses->audio_filter_info = data->audio_filter_info;
-		sip_rtp_ses->video_filter_info = data->video_filter_info;
-	}
+    if (self->priv->sessionData != NULL) {
+      data = (KmsSipRtpEndpointCloneData *) self->priv->sessionData->data;
+      sip_rtp_ses->audio_filter_info = data->audio_filter_info;
+      sip_rtp_ses->video_filter_info = data->video_filter_info;
+    }
   }
 
   /* Chain up */
@@ -303,28 +322,26 @@ kms_sip_rtp_endpoint_create_session_internal (KmsBaseSdpEndpoint * base_sdp,
 //  KMS_BASE_SDP_ENDPOINT_CLASS(
 //  (KMS_RTP_ENDPOINT_CLASS
 //      (kms_sip_rtp_endpoint_parent_class)->parent_class)->
-//	  ->create_session_internal (base_sdp, id, sess);
+//        ->create_session_internal (base_sdp, id, sess);
 
   if (self->priv->sessionData != NULL) {
-	  kms_sip_rtp_endpoint_clone_session (self, sess);
+    kms_sip_rtp_endpoint_clone_session (self, sess);
   }
 
 }
 
 /* Internal session management end */
 
-
 static void
 kms_sip_rtp_endpoint_create_media_handler (KmsBaseSdpEndpoint * base_sdp,
     const gchar * media, KmsSdpMediaHandler ** handler)
 {
-	KMS_BASE_SDP_ENDPOINT_CLASS(kms_sip_rtp_endpoint_parent_class)->create_media_handler (base_sdp, media, handler);
+  KMS_BASE_SDP_ENDPOINT_CLASS
+      (kms_sip_rtp_endpoint_parent_class)->create_media_handler (base_sdp,
+      media, handler);
 
 }
 
-
-
-
 /* Configure media SDP begin */
 static gboolean
 kms_sip_rtp_endpoint_configure_media (KmsBaseSdpEndpoint * base_sdp_endpoint,
@@ -333,8 +350,10 @@ kms_sip_rtp_endpoint_configure_media (KmsBaseSdpEndpoint * base_sdp_endpoint,
   gboolean ret = TRUE;
 
   /* Chain up */
-  ret = 	KMS_BASE_SDP_ENDPOINT_CLASS(kms_sip_rtp_endpoint_parent_class)->
-		  	  configure_media (base_sdp_endpoint, sess, handler, media);
+  ret =
+      KMS_BASE_SDP_ENDPOINT_CLASS
+      (kms_sip_rtp_endpoint_parent_class)->configure_media (base_sdp_endpoint,
+      sess, handler, media);
   return ret;
 }
 
@@ -343,46 +362,45 @@ kms_sip_rtp_endpoint_configure_media (KmsBaseSdpEndpoint * base_sdp_endpoint,
 //static void
 //kms_sip_rtp_endpoint_set_connection_filter_probe (KmsSipRtpEndpoint *self, KmsIRtpConnection *conn, KmsBaseRtpSession *ses, guint32 expected_ssrc)
 //{
-//	if (KMS_IS_RTP_CONNECTION (conn)) {
-//		gulong rtp_probe, rtcp_probe;
-//		KmsSipRtpSession *sip_ses = KMS_SIP_RTP_SESSION (ses);
-//		KmsRtpConnection *rtp_conn = KMS_RTP_CONNECTION (conn);
+//      if (KMS_IS_RTP_CONNECTION (conn)) {
+//              gulong rtp_probe, rtcp_probe;
+//              KmsSipRtpSession *sip_ses = KMS_SIP_RTP_SESSION (ses);
+//              KmsRtpConnection *rtp_conn = KMS_RTP_CONNECTION (conn);
 //
-//		kms_sip_rtp_connection_add_probes (rtp_conn, filter_info, &rtp_probe, &rtcp_probe);
-//		KMS_SIP_RTP_SESSION_CLASS(G_OBJECT_GET_CLASS(ses))->store_rtp_filtering_info (sip_ses, rtp_conn, rtp_probe, rtcp_probe);
-//	} else if (KMS_IS_SRTP_CONNECTION (conn)) {
-//		gulong rtp_probe, rtcp_probe;
-//		KmsSipSrtpSession *sip_ses = KMS_SIP_SRTP_SESSION (ses);
-//		KmsSrtpConnection *rtp_conn = KMS_SRTP_CONNECTION (conn);
+//              kms_sip_rtp_connection_add_probes (rtp_conn, filter_info, &rtp_probe, &rtcp_probe);
+//              KMS_SIP_RTP_SESSION_CLASS(G_OBJECT_GET_CLASS(ses))->store_rtp_filtering_info (sip_ses, rtp_conn, rtp_probe, rtcp_probe);
+//      } else if (KMS_IS_SRTP_CONNECTION (conn)) {
+//              gulong rtp_probe, rtcp_probe;
+//              KmsSipSrtpSession *sip_ses = KMS_SIP_SRTP_SESSION (ses);
+//              KmsSrtpConnection *rtp_conn = KMS_SRTP_CONNECTION (conn);
 //
-//		kms_sip_srtp_connection_add_probes (rtp_conn, filter_info, &rtp_probe, &rtcp_probe);
-//		KMS_SIP_SRTP_SESSION_CLASS(G_OBJECT_GET_CLASS(ses))->store_rtp_filtering_info (sip_ses, rtp_conn, rtp_probe, rtcp_probe);
-//	}
+//              kms_sip_srtp_connection_add_probes (rtp_conn, filter_info, &rtp_probe, &rtcp_probe);
+//              KMS_SIP_SRTP_SESSION_CLASS(G_OBJECT_GET_CLASS(ses))->store_rtp_filtering_info (sip_ses, rtp_conn, rtp_probe, rtcp_probe);
+//      }
 //}
 
-
 //static void
 //kms_sip_rtp_endpoint_set_filter_probes (KmsSipRtpEndpoint *self, guint32 expected_audio_ssrc, guint32 expected_video_ssrc)
 //{
-//	GHashTable * sessions = kms_base_sdp_endpoint_get_sessions (KMS_BASE_SDP_ENDPOINT(self));
-//	GList *sessionKeys = g_hash_table_get_keys (sessions);
-//	gint i;
-//	KmsIRtpConnection *conn;
+//      GHashTable * sessions = kms_base_sdp_endpoint_get_sessions (KMS_BASE_SDP_ENDPOINT(self));
+//      GList *sessionKeys = g_hash_table_get_keys (sessions);
+//      gint i;
+//      KmsIRtpConnection *conn;
 //
-//	// In fact SipRtpEndpoint should have only one session, if not, this loop should be revised
-//	for (i = 0; i < g_hash_table_size(sessions); i++) {
-//		gpointer sesKey = sessionKeys->data;
-//		KmsBaseRtpSession *ses = KMS_BASE_RTP_SESSION (g_hash_table_lookup (sessions, sesKey));
+//      // In fact SipRtpEndpoint should have only one session, if not, this loop should be revised
+//      for (i = 0; i < g_hash_table_size(sessions); i++) {
+//              gpointer sesKey = sessionKeys->data;
+//              KmsBaseRtpSession *ses = KMS_BASE_RTP_SESSION (g_hash_table_lookup (sessions, sesKey));
 //
-//		// AUDIO
-//		conn = g_hash_table_lookup (ses->conns, AUDIO_RTP_SESSION_STR);
-//		kms_sip_rtp_endpoint_set_connection_filter_probe (self, conn, ses, expected_audio_ssrc);
+//              // AUDIO
+//              conn = g_hash_table_lookup (ses->conns, AUDIO_RTP_SESSION_STR);
+//              kms_sip_rtp_endpoint_set_connection_filter_probe (self, conn, ses, expected_audio_ssrc);
 //
-//		// VIDEO
-//		conn = g_hash_table_lookup (ses->conns, VIDEO_RTP_SESSION_STR);
-//		kms_sip_rtp_endpoint_set_connection_filter_probe (self, conn, ses, expected_video_ssrc);
-//	}
-//	g_list_free(sessionKeys);
+//              // VIDEO
+//              conn = g_hash_table_lookup (ses->conns, VIDEO_RTP_SESSION_STR);
+//              kms_sip_rtp_endpoint_set_connection_filter_probe (self, conn, ses, expected_video_ssrc);
+//      }
+//      g_list_free(sessionKeys);
 //}
 
 static guint
@@ -427,164 +445,190 @@ sdp_media_get_ssrc_str (const GstSDPMedia * media)
 }
 
 static guint32
-kms_sip_rtp_endpoint_get_ssrc (const GstSDPMedia* media)
+kms_sip_rtp_endpoint_get_ssrc (const GstSDPMedia * media)
 {
-	gchar *ssrc_str;
-	guint32 ssrc = 0;
+  gchar *ssrc_str;
+  guint32 ssrc = 0;
 
-	ssrc_str = sdp_media_get_ssrc_str (media);
-	if (ssrc_str == NULL) {
-	  return 0;
-	}
+  ssrc_str = sdp_media_get_ssrc_str (media);
+  if (ssrc_str == NULL) {
+    return 0;
+  }
 
-	ssrc = ssrc_str_to_uint (ssrc_str);
-	g_free (ssrc_str);
+  ssrc = ssrc_str_to_uint (ssrc_str);
+  g_free (ssrc_str);
 
-	return ssrc;
+  return ssrc;
 }
 
-
 static gboolean
-kms_sip_rtp_endpoint_get_expected_ssrc (const GstSDPMessage *sdp, guint32 *audio_ssrc, guint32 *video_ssrc)
+kms_sip_rtp_endpoint_get_expected_ssrc (const GstSDPMessage * sdp,
+    guint32 * audio_ssrc, guint32 * video_ssrc)
 {
-	const GstSDPMedia *media;
-	guint idx = 0;
-	guint num_medias = 0;
-	gboolean result = TRUE;
-
-	// We are expecting an SDP answer with just one audio media and just one video media
-	// If this was to change, this function would need reconsidering
-	num_medias = gst_sdp_message_medias_len  (sdp);
-	while (idx < num_medias) {
-		const gchar* media_name;
-
-		media = gst_sdp_message_get_media (sdp, idx);
-		media_name = gst_sdp_media_get_media (media);
-		GST_DEBUG("Found media %s", media_name);
-
-		if (g_strcmp0 (AUDIO_STREAM_NAME, media_name) == 0) {
-			*audio_ssrc = kms_sip_rtp_endpoint_get_ssrc (media);
-		} else if (g_strcmp0 (VIDEO_STREAM_NAME, media_name) == 0) {
-			*video_ssrc = kms_sip_rtp_endpoint_get_ssrc (media);
-		} else  {
-			result = FALSE;
-		}
-		idx++;
-	}
-
-	return result;
-}
-
+  const GstSDPMedia *media;
+  guint idx = 0;
+  guint num_medias = 0;
+  gboolean result = TRUE;
+
+  // We are expecting an SDP answer with just one audio media and just one video media
+  // If this was to change, this function would need reconsidering
+  num_medias = gst_sdp_message_medias_len (sdp);
+  while (idx < num_medias) {
+    const gchar *media_name;
+
+    media = gst_sdp_message_get_media (sdp, idx);
+    media_name = gst_sdp_media_get_media (media);
+    GST_DEBUG ("Found media %s", media_name);
+
+    if (g_strcmp0 (AUDIO_STREAM_NAME, media_name) == 0) {
+      *audio_ssrc = kms_sip_rtp_endpoint_get_ssrc (media);
+    } else if (g_strcmp0 (VIDEO_STREAM_NAME, media_name) == 0) {
+      *video_ssrc = kms_sip_rtp_endpoint_get_ssrc (media);
+    } else {
+      result = FALSE;
+    }
+    idx++;
+  }
 
+  return result;
+}
 
 static gboolean
 kms_sip_rtp_endpoint_process_answer (KmsBaseSdpEndpoint * ep,
     const gchar * sess_id, GstSDPMessage * answer)
 {
-//	KmsSipRtpEndpoint *self = KMS_SIP_RTP_ENDPOINT(ep);
-//	guint32 expected_audio_ssrc = 0;
-//	guint32 expected_video_ssrc = 0;
+//      KmsSipRtpEndpoint *self = KMS_SIP_RTP_ENDPOINT(ep);
+//      guint32 expected_audio_ssrc = 0;
+//      guint32 expected_video_ssrc = 0;
 //
-//	kms_sip_rtp_endpoint_get_expected_ssrc (answer, &expected_audio_ssrc, &expected_video_ssrc);
-//	kms_sip_rtp_endpoint_set_filter_probes (self);
-	return KMS_BASE_SDP_ENDPOINT_CLASS(kms_sip_rtp_endpoint_parent_class)->process_answer (ep, sess_id, answer);
+//      kms_sip_rtp_endpoint_get_expected_ssrc (answer, &expected_audio_ssrc, &expected_video_ssrc);
+//      kms_sip_rtp_endpoint_set_filter_probes (self);
+  return
+      KMS_BASE_SDP_ENDPOINT_CLASS
+      (kms_sip_rtp_endpoint_parent_class)->process_answer (ep, sess_id, answer);
 }
 
 static void
-kms_sip_rtp_endpoint_start_transport_send (KmsBaseSdpEndpoint *base_sdp_endpoint,
-    KmsSdpSession *sess, gboolean offerer)
+kms_sip_rtp_endpoint_start_transport_send (KmsBaseSdpEndpoint *
+    base_sdp_endpoint, KmsSdpSession * sess, gboolean offerer)
 {
-	KMS_BASE_SDP_ENDPOINT_CLASS(kms_sip_rtp_endpoint_parent_class)->start_transport_send (base_sdp_endpoint, sess, offerer);
+  KMS_BASE_SDP_ENDPOINT_CLASS
+      (kms_sip_rtp_endpoint_parent_class)->start_transport_send
+      (base_sdp_endpoint, sess, offerer);
 
 }
 
-static KmsSipRtpEndpointCloneData*
-kms_sip_rtp_endpoint_create_clone_data (KmsSipRtpEndpoint *self, KmsBaseRtpSession *ses, guint32 audio_ssrc, guint32 video_ssrc, gboolean continue_audio_stream, gboolean continue_video_stream)
+static KmsSipRtpEndpointCloneData *
+kms_sip_rtp_endpoint_create_clone_data (KmsSipRtpEndpoint * self,
+    KmsBaseRtpSession * ses, guint32 audio_ssrc, guint32 video_ssrc,
+    gboolean continue_audio_stream, gboolean continue_video_stream)
 {
-	KmsSipRtpEndpointCloneData *data = g_malloc(sizeof (KmsSipRtpEndpointCloneData));
-	SipFilterSsrcInfo* audio_filter_info = NULL;
-	SipFilterSsrcInfo* video_filter_info = NULL;
-
-	data->local_audio_ssrc = ses->local_audio_ssrc;
-	data->local_video_ssrc = ses->local_video_ssrc;
-
-	if (KMS_IS_SIP_RTP_SESSION (ses)) {
-		KmsSipRtpSession* sip_ses = KMS_SIP_RTP_SESSION (ses);
-
-		GST_DEBUG ("kms_sip_rtp_endpoint_create_clone_data audio filter %p, video filter %p", sip_ses->audio_filter_info, sip_ses->video_filter_info);
-		audio_filter_info = kms_sip_rtp_filter_create_filtering_info (audio_ssrc, sip_ses->audio_filter_info, AUDIO_RTP_SESSION, continue_audio_stream);
-		video_filter_info = kms_sip_rtp_filter_create_filtering_info (video_ssrc, sip_ses->video_filter_info, VIDEO_RTP_SESSION, continue_video_stream);
-	} else if (KMS_IS_SIP_SRTP_SESSION (ses)) {
-		KmsSipSrtpSession* sip_ses = KMS_SIP_SRTP_SESSION (ses);
-
-		GST_DEBUG ("kms_sip_rtp_endpoint_create_clone_data srtp  audio filter %p, video filter %p", sip_ses->audio_filter_info, sip_ses->video_filter_info);
-		audio_filter_info = kms_sip_rtp_filter_create_filtering_info (audio_ssrc, sip_ses->audio_filter_info, AUDIO_RTP_SESSION, continue_audio_stream);
-		video_filter_info = kms_sip_rtp_filter_create_filtering_info (video_ssrc, sip_ses->video_filter_info, VIDEO_RTP_SESSION, continue_video_stream);
-	}
+  KmsSipRtpEndpointCloneData *data =
+      g_malloc (sizeof (KmsSipRtpEndpointCloneData));
+  SipFilterSsrcInfo *audio_filter_info = NULL;
+  SipFilterSsrcInfo *video_filter_info = NULL;
+
+  data->local_audio_ssrc = ses->local_audio_ssrc;
+  data->local_video_ssrc = ses->local_video_ssrc;
+
+  if (KMS_IS_SIP_RTP_SESSION (ses)) {
+    KmsSipRtpSession *sip_ses = KMS_SIP_RTP_SESSION (ses);
+
+    GST_DEBUG
+        ("kms_sip_rtp_endpoint_create_clone_data audio filter %p, video filter %p",
+        sip_ses->audio_filter_info, sip_ses->video_filter_info);
+    audio_filter_info =
+        kms_sip_rtp_filter_create_filtering_info (audio_ssrc,
+        sip_ses->audio_filter_info, AUDIO_RTP_SESSION, continue_audio_stream);
+    video_filter_info =
+        kms_sip_rtp_filter_create_filtering_info (video_ssrc,
+        sip_ses->video_filter_info, VIDEO_RTP_SESSION, continue_video_stream);
+  } else if (KMS_IS_SIP_SRTP_SESSION (ses)) {
+    KmsSipSrtpSession *sip_ses = KMS_SIP_SRTP_SESSION (ses);
+
+    GST_DEBUG
+        ("kms_sip_rtp_endpoint_create_clone_data srtp  audio filter %p, video filter %p",
+        sip_ses->audio_filter_info, sip_ses->video_filter_info);
+    audio_filter_info =
+        kms_sip_rtp_filter_create_filtering_info (audio_ssrc,
+        sip_ses->audio_filter_info, AUDIO_RTP_SESSION, continue_audio_stream);
+    video_filter_info =
+        kms_sip_rtp_filter_create_filtering_info (video_ssrc,
+        sip_ses->video_filter_info, VIDEO_RTP_SESSION, continue_video_stream);
+  }
 
-	data->audio_filter_info = audio_filter_info;
-	data->video_filter_info = video_filter_info;
-	data->conns = g_hash_table_ref(ses->conns);
+  data->audio_filter_info = audio_filter_info;
+  data->video_filter_info = video_filter_info;
+  data->conns = g_hash_table_ref (ses->conns);
 
-	return data;
+  return data;
 }
 
 static void
-kms_sip_rtp_endpoint_free_clone_data (GList *data)
+kms_sip_rtp_endpoint_free_clone_data (GList * data)
 {
-	GList *it = data;
+  GList *it = data;
 
-	while (it != NULL) {
-		KmsSipRtpEndpointCloneData* data = (KmsSipRtpEndpointCloneData*) it->data;
+  while (it != NULL) {
+    KmsSipRtpEndpointCloneData *data = (KmsSipRtpEndpointCloneData *) it->data;
 
-		if (data->conns != NULL) {
-			g_hash_table_unref(data->conns);
-			data->conns = NULL;
-		}
+    if (data->conns != NULL) {
+      g_hash_table_unref (data->conns);
+      data->conns = NULL;
+    }
 
-		it = it->next;
-	}
+    it = it->next;
+  }
 
-	g_list_free_full (data, g_free);
+  g_list_free_full (data, g_free);
 }
 
 static void
-kms_sip_rtp_endpoint_clone_to_new_ep (KmsSipRtpEndpoint *self, KmsSipRtpEndpoint *cloned, const gchar* sdp_str, gboolean continue_audio_stream, gboolean continue_video_stream)
+kms_sip_rtp_endpoint_clone_to_new_ep (KmsSipRtpEndpoint * self,
+    KmsSipRtpEndpoint * cloned, const gchar * sdp_str,
+    gboolean continue_audio_stream, gboolean continue_video_stream)
 {
-	GHashTable * sessions = kms_base_sdp_endpoint_get_sessions (KMS_BASE_SDP_ENDPOINT(self));
-	GList *sessionKeys = g_hash_table_get_keys (sessions);
-	gint i;
-	GList *sessionsData = NULL;
-	guint32 remote_audio_ssrc = 0;
-	guint32 remote_video_ssrc = 0;
-	GstSDPMessage *sdp;
-
-	gst_sdp_message_new (&sdp);
-	if (gst_sdp_message_parse_buffer ((const guint8*) sdp_str, strlen (sdp_str), sdp) != GST_SDP_OK)
-		GST_ERROR("Could not parse SDP answer");
-
-	if (!kms_sip_rtp_endpoint_get_expected_ssrc (sdp, &remote_audio_ssrc, &remote_video_ssrc)) {
-		GST_INFO("Could not find SSRCs on SDP answer, assuming first SSRC different from previous is valid");
-	}
-
-	gst_sdp_message_free (sdp);
-
-	// In fact SipRtpEndpoint should have only one session, if not, this loop should be revised
-	for (i = 0; i < g_hash_table_size(sessions); i++) {
-		gpointer sesKey = sessionKeys->data;
-		KmsBaseRtpSession *ses = KMS_BASE_RTP_SESSION (g_hash_table_lookup (sessions, sesKey));
-		KmsSipRtpEndpointCloneData *data = kms_sip_rtp_endpoint_create_clone_data (self, ses, remote_audio_ssrc, remote_video_ssrc, continue_audio_stream, continue_video_stream);
-
-		sessionsData = g_list_append (sessionsData, (gpointer)data);
-	}
-	g_list_free(sessionKeys);
-
-	KMS_ELEMENT_LOCK (cloned);
-	if (cloned->priv->sessionData != NULL) {
-		kms_sip_rtp_endpoint_free_clone_data (cloned->priv->sessionData);
-	}
-	cloned->priv->sessionData = sessionsData;
-	KMS_ELEMENT_UNLOCK (cloned);
+  GHashTable *sessions =
+      kms_base_sdp_endpoint_get_sessions (KMS_BASE_SDP_ENDPOINT (self));
+  GList *sessionKeys = g_hash_table_get_keys (sessions);
+  gint i;
+  GList *sessionsData = NULL;
+  guint32 remote_audio_ssrc = 0;
+  guint32 remote_video_ssrc = 0;
+  GstSDPMessage *sdp;
+
+  gst_sdp_message_new (&sdp);
+  if (gst_sdp_message_parse_buffer ((const guint8 *) sdp_str, strlen (sdp_str),
+          sdp) != GST_SDP_OK)
+    GST_ERROR ("Could not parse SDP answer");
+
+  if (!kms_sip_rtp_endpoint_get_expected_ssrc (sdp, &remote_audio_ssrc,
+          &remote_video_ssrc)) {
+    GST_INFO
+        ("Could not find SSRCs on SDP answer, assuming first SSRC different from previous is valid");
+  }
+
+  gst_sdp_message_free (sdp);
+
+  // In fact SipRtpEndpoint should have only one session, if not, this loop should be revised
+  for (i = 0; i < g_hash_table_size (sessions); i++) {
+    gpointer sesKey = sessionKeys->data;
+    KmsBaseRtpSession *ses =
+        KMS_BASE_RTP_SESSION (g_hash_table_lookup (sessions, sesKey));
+    KmsSipRtpEndpointCloneData *data =
+        kms_sip_rtp_endpoint_create_clone_data (self, ses, remote_audio_ssrc,
+        remote_video_ssrc, continue_audio_stream, continue_video_stream);
+
+    sessionsData = g_list_append (sessionsData, (gpointer) data);
+  }
+  g_list_free (sessionKeys);
+
+  KMS_ELEMENT_LOCK (cloned);
+  if (cloned->priv->sessionData != NULL) {
+    kms_sip_rtp_endpoint_free_clone_data (cloned->priv->sessionData);
+  }
+  cloned->priv->sessionData = sessionsData;
+  KMS_ELEMENT_UNLOCK (cloned);
 }
 
 static void
@@ -596,25 +640,25 @@ kms_sip_rtp_endpoint_set_property (GObject * object, guint prop_id,
   KMS_ELEMENT_LOCK (self);
 
   switch (prop_id) {
-	KmsSipRtpEndpointCloneData* clone;
-	guint32 ssrc;
-
-	  case PROP_AUDIO_SSRC:
-		  clone = kms_sip_rtp_endpoint_get_clone_data (self->priv->sessionData);
-		  ssrc = g_value_get_uint (value);
-
-		  if (clone != NULL) {
-			  clone->local_audio_ssrc = ssrc;
-		  }
-		  break;
-	  case PROP_VIDEO_SSRC:
-		  clone = kms_sip_rtp_endpoint_get_clone_data (self->priv->sessionData);
-		  ssrc = g_value_get_uint (value);
-
-		  if (clone != NULL) {
-			  clone->local_video_ssrc = ssrc;
-		  }
-		  break;
+      KmsSipRtpEndpointCloneData *clone;
+      guint32 ssrc;
+
+    case PROP_AUDIO_SSRC:
+      clone = kms_sip_rtp_endpoint_get_clone_data (self->priv->sessionData);
+      ssrc = g_value_get_uint (value);
+
+      if (clone != NULL) {
+        clone->local_audio_ssrc = ssrc;
+      }
+      break;
+    case PROP_VIDEO_SSRC:
+      clone = kms_sip_rtp_endpoint_get_clone_data (self->priv->sessionData);
+      ssrc = g_value_get_uint (value);
+
+      if (clone != NULL) {
+        clone->local_video_ssrc = ssrc;
+      }
+      break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
       break;
@@ -632,22 +676,22 @@ kms_sip_rtp_endpoint_get_property (GObject * object, guint prop_id,
   KMS_ELEMENT_LOCK (self);
 
   switch (prop_id) {
-	KmsSipRtpEndpointCloneData* clone;
+      KmsSipRtpEndpointCloneData *clone;
 
     case PROP_AUDIO_SSRC:
-    	clone = kms_sip_rtp_endpoint_get_clone_data (self->priv->sessionData);
+      clone = kms_sip_rtp_endpoint_get_clone_data (self->priv->sessionData);
 
-    	if (clone != NULL) {
-    		g_value_set_uint (value, clone->local_audio_ssrc);
-    	}
-    	break;
+      if (clone != NULL) {
+        g_value_set_uint (value, clone->local_audio_ssrc);
+      }
+      break;
     case PROP_VIDEO_SSRC:
-    	clone = kms_sip_rtp_endpoint_get_clone_data (self->priv->sessionData);
+      clone = kms_sip_rtp_endpoint_get_clone_data (self->priv->sessionData);
 
-    	if (clone != NULL) {
-    		g_value_set_uint (value, clone->local_video_ssrc);
-    	}
-    	break;
+      if (clone != NULL) {
+        g_value_set_uint (value, clone->local_video_ssrc);
+      }
+      break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
       break;
@@ -664,10 +708,10 @@ kms_sip_rtp_endpoint_finalize (GObject * object)
   GST_DEBUG_OBJECT (self, "finalize");
 
   if (self->priv->use_sdes_cache != NULL)
-	  g_free (self->priv->use_sdes_cache);
+    g_free (self->priv->use_sdes_cache);
 
   if (self->priv->sessionData != NULL)
-	  kms_sip_rtp_endpoint_free_clone_data(self->priv->sessionData);
+    kms_sip_rtp_endpoint_free_clone_data (self->priv->sessionData);
 
   GST_DEBUG ("Finalizing Sip RTP Endpoint %p", object);
 
@@ -675,7 +719,6 @@ kms_sip_rtp_endpoint_finalize (GObject * object)
   G_OBJECT_CLASS (parent_class)->finalize (object);
 }
 
-
 static void
 kms_sip_rtp_endpoint_class_init (KmsSipRtpEndpointClass * klass)
 {
@@ -702,15 +745,14 @@ kms_sip_rtp_endpoint_class_init (KmsSipRtpEndpointClass * klass)
   base_sdp_endpoint_class->start_transport_send =
       kms_sip_rtp_endpoint_start_transport_send;
 
-  base_sdp_endpoint_class->process_answer =
-		  kms_sip_rtp_endpoint_process_answer;
+  base_sdp_endpoint_class->process_answer = kms_sip_rtp_endpoint_process_answer;
 
   /* Media handler management */
   base_sdp_endpoint_class->create_media_handler =
       kms_sip_rtp_endpoint_create_media_handler;
 
-
-  base_sdp_endpoint_class->configure_media = kms_sip_rtp_endpoint_configure_media;
+  base_sdp_endpoint_class->configure_media =
+      kms_sip_rtp_endpoint_configure_media;
 
   klass->clone_to_new_ep = kms_sip_rtp_endpoint_clone_to_new_ep;
 
@@ -718,22 +760,21 @@ kms_sip_rtp_endpoint_class_init (KmsSipRtpEndpointClass * klass)
       g_param_spec_uint ("audio-ssrc",
           "Audio SSRC", "Set to assign the local audio SSRC",
           0, G_MAXUINT, DEFAULT_AUDIO_SSRC,
-		  G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+          G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 
   g_object_class_install_property (gobject_class, PROP_VIDEO_SSRC,
       g_param_spec_uint ("video-ssrc",
           "Video SSRC", "Set to assign the local video SSRC",
-		  0, G_MAXUINT, DEFAULT_VIDEO_SSRC,
-		  G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
-
+          0, G_MAXUINT, DEFAULT_VIDEO_SSRC,
+          G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 
   obj_signals[SIGNAL_CLONE_TO_NEW_EP] =
       g_signal_new ("clone-to-new-ep",
       G_TYPE_FROM_CLASS (klass),
       G_SIGNAL_ACTION | G_SIGNAL_RUN_LAST,
       G_STRUCT_OFFSET (KmsSipRtpEndpointClass, clone_to_new_ep), NULL, NULL,
-      NULL, G_TYPE_NONE, 4, G_TYPE_POINTER, G_TYPE_STRING, G_TYPE_BOOLEAN, G_TYPE_BOOLEAN);
-
+      NULL, G_TYPE_NONE, 4, G_TYPE_POINTER, G_TYPE_STRING, G_TYPE_BOOLEAN,
+      G_TYPE_BOOLEAN);
 
   g_type_class_add_private (klass, sizeof (KmsSipRtpEndpointPrivate));
 
@@ -746,11 +787,13 @@ kms_sip_rtp_endpoint_class_init (KmsSipRtpEndpointClass * klass)
   //  subclasses to reimplement the virtual method (in the particular case of
   //  create_session_internal just need to skip session creation if already created.
   // TODO: When integrate on kms-elements get rid off this hack changing kms_rtp_endpoint_create_session_internal
-  GType type =   g_type_parent  (g_type_parent (G_TYPE_FROM_CLASS (klass)));
+  GType type = g_type_parent (g_type_parent (G_TYPE_FROM_CLASS (klass)));
+
   // TODO: This introduces a memory leak, this is reserved and never freed, but it is just a pointer (64 bits)
   //       A possible alternative would be to implement the class_finalize method
-  gpointer typePointer = g_type_class_ref(type);
-  base_sdp_endpoint_type = KMS_BASE_SDP_ENDPOINT_CLASS(typePointer);
+  gpointer typePointer = g_type_class_ref (type);
+
+  base_sdp_endpoint_type = KMS_BASE_SDP_ENDPOINT_CLASS (typePointer);
 }
 
 /* TODO: not add abs-send-time extmap */
